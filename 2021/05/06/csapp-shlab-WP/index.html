<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>csapp-shlab-WP - 王某杂谈</title>

  
    <meta name="description" content="shlab 笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="csapp-shlab-WP">
<meta property="og:url" content="http://example.com/2021/05/06/csapp-shlab-WP/index.html">
<meta property="og:site_name" content="王某杂谈">
<meta property="og:description" content="shlab 笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-06T09:17:27.000Z">
<meta property="article:modified_time" content="2021-05-07T01:27:17.276Z">
<meta property="article:author" content="Zuni">
<meta property="article:tag" content="作业">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left'>
    

<header class='header'>
  <div class='logo-wrap'>
  
  
    <a class='title' href='/'>
      王某杂谈
    </a>
  
</div>

  <nav class="menu dis-select"><a class="nav-item active" href="/">博客</a><a class="nav-item" href="/wiki/">wiki</a><a class="nav-item" href="/friends/">友链</a><a class="nav-item" href="/about/">关于</a></nav>
</header>

<div class='widgets'>
  
    
      
      
<div class="widget-wrap" id="toc"><div class="widget-header h4 dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14 post"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#shlab%E7%AE%80%E4%BB%8B"><span class="toc-text">shlab简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shlab%E5%86%85%E9%83%A8%E5%88%86%E6%9E%90"><span class="toc-text">shlab内部分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-text">库文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">宏定义与结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A5%BD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">实现好的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%85%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">待实现的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%BB%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-text">主函数（主流程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%82%B9%E8%A6%81%E6%B1%82"><span class="toc-text">测试点要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%98%BB%E5%A1%9E"><span class="toc-text">信号阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-text">进程回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%84%E7%90%86%E7%82%B9"><span class="toc-text">具体函数与处理点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-text">后记</span></a></li></ol></div></div></div>

    
  
</div>


    </aside>
    <div class='l_main'>
      

      


  <div class='bread-nav fs12'>
  
    
    <div id='breadcrumb'>
      <a class='cap breadcrumb' href='/'>主页</a>
      <span class="sep"></span>
      <a class='cap breadcrumb' href='/'>文章</a>
      
    </div>
    <div id='post-meta'>
      发布于&nbsp;<time datetime='2021-05-06T09:17:27.000Z'>2021-05-06</time>
    </div>
  
  </div>


<article class='content md post'>
<h1 class="article-title"><span>csapp-shlab-WP</span></h1>
<p>shlab 笔记</p>
<span id="more"></span>

<p>五一周之前做了shlab，现在重整思绪写笔记</p>
<h2 id="shlab简介"><a href="#shlab简介" class="headerlink" title="shlab简介"></a>shlab简介</h2><p>本lab主要是通过手动补全一个tsh代码并编译实现简单的shlab功能，具体有</p>
<ol>
<li>区分内外置命令，并调用</li>
<li>前后台运行转换</li>
<li>异常信号输入与处理</li>
</ol>
<p>需要实现的函数有七个，下方会提到</p>
<p>有15个测试点，最好按照测试点指引逐步完善功能。</p>
<h2 id="shlab内部分析"><a href="#shlab内部分析" class="headerlink" title="shlab内部分析"></a>shlab内部分析</h2><h4 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h4><ol>
<li><p>stdio.h </p>
<p>C标准输入输出</p>
</li>
<li><p>stdlib.h</p>
<p>标准库引入系统函数</p>
</li>
<li><p>unistd.h</p>
<p>posix的api</p>
</li>
<li><p>string.h</p>
<p>字符串算法</p>
</li>
<li><p>ctype.h</p>
<p>类型测试</p>
</li>
<li><p>signal.h</p>
<p>信号报告</p>
</li>
<li><p>sys/types.h</p>
<p>类型引入</p>
</li>
<li><p>sys/wait.h</p>
<p>wait/waitpid</p>
</li>
<li><p>errno.h</p>
<p>确认错误类型</p>
</li>
</ol>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>int verbose 是否显示</p>
<p>int nextjid 下一个job id</p>
<p>char *sbuf 辅助命令行解析</p>
<h4 id="宏定义与结构体"><a href="#宏定义与结构体" class="headerlink" title="宏定义与结构体"></a>宏定义与结构体</h4><ol>
<li><p>job states </p>
<p>undef，fg，bg，st</p>
</li>
<li><p>job_t</p>
<ul>
<li>pid_t pid（标识进程）</li>
<li>int jid（在job列表中的id）</li>
<li>int state （如1）</li>
<li>char* cmdline（对应的指令字符串）</li>
</ul>
</li>
</ol>
<h4 id="实现好的函数"><a href="#实现好的函数" class="headerlink" title="实现好的函数"></a>实现好的函数</h4><ol>
<li><p>int parseline(const char *cmdline, char **argv); </p>
<p>解析字符串到argv，并返回fg/bg</p>
</li>
<li><p>void sigquit_handler(int sig);</p>
<p>退出tsh</p>
</li>
<li><p>void clearjob(struct job_t *job);</p>
<p>将传入的job实参清零（初始化）</p>
</li>
<li><p>void initjobs(struct job_t *jobs);</p>
<p>将全部job清零</p>
</li>
<li><p>int maxjid(struct job_t *jobs); </p>
<p>返回最大的jid</p>
</li>
<li><p>int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);</p>
<p>将传入的pid生成一个新的jid，并返回是否成功</p>
</li>
<li><p>int deletejob(struct job_t *jobs, pid_t pid); </p>
<p>删除某个job并更新nextjib</p>
</li>
<li><p>pid_t fgpid(struct job_t *jobs);</p>
<p>返回当前进程的pid</p>
</li>
<li><p>struct job_t *getjobpid(struct job_t *jobs, pid_t pid);</p>
<p>rt</p>
</li>
<li><p>struct job_t *getjobjid(struct job_t *jobs, int jid); </p>
<p>rt</p>
</li>
<li><p>int pid2jid(pid_t pid); </p>
<p>rt</p>
</li>
<li><p>void listjobs(struct job_t *jobs);</p>
<p>列出所有job</p>
</li>
<li><p>void usage(void);</p>
<p>打印帮助</p>
</li>
<li><p>void unix_error(char *msg);</p>
<p>rt</p>
</li>
<li><p>void app_error(char *msg);</p>
<p>rt</p>
</li>
<li><p>handler_t *Signal(int signum, handler_t *handler);</p>
<p>设置信号配套的处理函数</p>
</li>
</ol>
<h4 id="待实现的函数"><a href="#待实现的函数" class="headerlink" title="待实现的函数"></a>待实现的函数</h4><ul>
<li><strong>命令行函数</strong></li>
</ul>
<ol>
<li><p>void eval(char *cmdline)</p>
<p>解析cmdline，并执行</p>
</li>
<li><p>buildin_cmd(char **argv)</p>
<p>识别内置命令</p>
</li>
<li><p>do_bgfg(char **argv)</p>
<p>前后台应用转换</p>
</li>
<li><p>waitfg(pid_t pid)</p>
<p>等待前台运行结束</p>
</li>
</ol>
<ul>
<li><strong>信号处理函数</strong></li>
</ul>
<ol>
<li><p>void sigchld_handler(int sig);</p>
<p>子进程处理</p>
</li>
<li><p>void sigtstp_handler(int sig);</p>
<p>stop信号处理，ctrl+z</p>
</li>
<li><p>void sigint_handler(int sig);</p>
<p>ctrl+c 处理</p>
</li>
</ol>
<h4 id="主函数（主流程）"><a href="#主函数（主流程）" class="headerlink" title="主函数（主流程）"></a>主函数（主流程）</h4><ol>
<li>解析主程序的输入并设置参数（详情/提示句/参数）</li>
<li>用我们的自定义函数处理某些信号（install the handlers）</li>
<li>创建工作列表</li>
<li>循环读取并运行<ol>
<li>输出提示句</li>
<li>特殊处理</li>
<li>eval</li>
</ol>
</li>
</ol>
<h4 id="测试点要求"><a href="#测试点要求" class="headerlink" title="测试点要求"></a>测试点要求</h4><ol>
<li>测试EOF（信号）main</li>
<li>quit（内置）eval-&gt;build</li>
<li>前台作业eval-&gt;waitfd</li>
<li>后台作业eval</li>
<li>jobs（内置）eval-&gt;build-&gt;listjobs</li>
<li>SIGINT（信号）SIGINT handler</li>
<li>终止前台后仍能正常运行后台</li>
<li>同上(进程问题)</li>
<li>bg（内置）（SIGTSTP重启）eval-&gt;build-&gt;dofgbg</li>
<li>fg（内置）（显示）eval-&gt;build-&gt;dofgbg</li>
<li>进程组SIGINT（直接停止，不再复活）</li>
<li>进程组SIGTSTP（暂时这终止，可复活）SIGTSTP handler</li>
<li>重启停止进程并结束掉</li>
<li>错误处理</li>
<li>综合信号测试</li>
<li>处理其他进程信号</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> &#123;01..06&#125;;<span class="keyword">do</span> make <span class="string">&quot;test<span class="variable">$var</span>&quot;</span>;<span class="keyword">done</span>;</span><br></pre></td></tr></table></figure>

<h4 id="信号阻塞"><a href="#信号阻塞" class="headerlink" title="信号阻塞"></a>信号阻塞</h4><p>在fork()新进程前要阻塞SIGCHLD信号,需要防止出现同步错误,</p>
<p>如果不阻塞，会出现子进程先结束，从jobs中删除作业deletejob，然后再执行到主进程增加作业addjob的竞争问题,保证先addjob,后deletejob.</p>
<p>这时需要通过系统调用sigprocmask实现信号阻塞或解除信号阻塞:</p>
<p>函数：sigprocmask(int how, const sigset_t *set, sigset_t *oldset)  </p>
<p>其中各参数分别为：  </p>
<p>SIG_BLOCK ：加入信号到进程屏蔽（blocked）；               </p>
<p>SIG_UNBLOCK ：从进程屏蔽里将信号删除；          </p>
<p>SIG_SETMASK ：将set的值设定为新的进程屏蔽；</p>
<p>set：指向信号集的指针,专指新设的信号集,如果仅想读取现在的屏蔽值,可将其置为NULL；</p>
<p>sigemptyset:清空信号集;</p>
<p>sigfillset:信号集填充全部信号;</p>
<p>sigaddset:信号集增加信号;</p>
<p>sigdelset:信号集中删除信号;</p>
<p>sigismember:判断信号集是否包含某信号;</p>
<p>oldset：也是指向信号集的指针，在此存放原来的信号集。</p>
<h4 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h4><p>返回成功的PID或WNOHANG（=0，没有终止子进程）或-1（错误）</p>
<p>函数pid_t waitpid(pid_t pid, int *status,int options);</p>
<p>  其中option：</p>
<p>1.WNOHANG:如果等待集合中的任何子进程都还没有终止，那么立马返回0，</p>
<pre><code>       默认行为是挂起调用进程，直到有子进程终止；
</code></pre>
<p>2.WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或被停止，</p>
<pre><code>          返回的pid为导致返回的已终止或被停止子进程的pid，

          默认行为是只返回已终止的子进程；
</code></pre>
<p>其中status参数如果非空，那么waitpid就会在status中放上关于导致返回的子进程的状态信息(终止或暂停原因)：</p>
<p>1.wifexited：正常终止，返回true；</p>
<p>2.wifsignaled：如果子进程是因为一个未被捕获的信号终止的，返回true；</p>
<p>3.wtermsig：返回导致子进程终止的信号的数量(wifsignaled返回true时才有此状态)</p>
<p>4.wifstopped：如果引起返回的子进程是被停止的，返回true；</p>
<p>5.wstopsig：返回引起子进程停止的信号的数量(wifstopped返回true时才有此状态)</p>
<p>当子进程状态改变时,将向其父进程发出SIGCHLD信号：</p>
<p>(1)子进程（前后台）终止时发出SIGCHLD信号</p>
<p>子进程终止时发出SIGCHLD信号后,父进程在信号 sigchld_handler处理中,回收僵尸进程并从jobs中删除该进程（父进程创建子进程加载用户程序完成用户作业,将作业按作业 结构加入作业列表,如果是前台,调用waitfg（sleep或sigsuspend）函数来等待jobs列 表中不存在前台进程返回）；</p>
<p>(2)子进程进入停止状态</p>
<p>此时只改变jobs中进程状态,打印引起进程停止的信号;</p>
<p>(3)子进程从stopped变到running（收到SIGCONT）</p>
<p>这时信号处理函数会一直等待它执行完毕,在shell中显示的情况就是卡住了;</p>
<p>解决方案是设置一个全局变量st_run_child记录需要从stopped到running的进程ID,</p>
<p>在进入信号处理函数后首先检查这个变量,如果是就直接退出不做处理。</p>
<h4 id="具体函数与处理点"><a href="#具体函数与处理点" class="headerlink" title="具体函数与处理点"></a>具体函数与处理点</h4><ul>
<li>命令行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">char</span>* bufs[<span class="number">133</span>];</span><br><span class="line">	<span class="keyword">int</span> bg=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">sigset_t</span> mask;</span><br><span class="line"></span><br><span class="line">	bg=parseline(cmdline,bufs);</span><br><span class="line">	<span class="keyword">if</span>(!builtin_cmd(bufs))</span><br><span class="line">	&#123;</span><br><span class="line">		sigemptyset(&amp;mask);<span class="comment">//清空mask</span></span><br><span class="line">		sigaddset(&amp;mask,SIGCHLD);<span class="comment">//mask加入SIGCHLD</span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;mask,<span class="literal">NULL</span>);<span class="comment">//信号屏蔽</span></span><br><span class="line">		<span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">		&#123;</span><br><span class="line">			sigprocmask(SIG_UNBLOCK,&amp;mask,<span class="literal">NULL</span>);<span class="comment">//解除屏蔽</span></span><br><span class="line">			<span class="keyword">if</span>(setpgid(<span class="number">0</span>,<span class="number">0</span>)&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;setpgid error&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>((execve(bufs[<span class="number">0</span>],bufs,environ))&lt;<span class="number">0</span>)<span class="comment">//运行</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s:Command not found.\n&quot;</span>,bufs[<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		&#123;</span><br><span class="line">			addjob(jobs,pid,bg?BG:FG,cmdline);</span><br><span class="line">			sigprocmask(SIG_UNBLOCK,&amp;mask,<span class="literal">NULL</span>);<span class="comment">//解除父进程屏蔽</span></span><br><span class="line">			<span class="keyword">if</span>(bg) <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,pid2jid(pid),pid,cmdline);</span><br><span class="line">			<span class="keyword">else</span> waitfg(pid);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)<span class="comment">//空判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>))||(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		do_bgfg(argv);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		listjobs(jobs);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>=</span><span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct <span class="keyword">job_t</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span>* id=argv[<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!id)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span>)<span class="comment">//jid</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> jid=atoi(id+<span class="number">1</span>);</span><br><span class="line">		job = getjobjid(jobs,jid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%%%d:No such job\n&quot;</span>,jid);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(id[<span class="number">0</span>]))<span class="comment">//pid</span></span><br><span class="line">	&#123;</span><br><span class="line">		pid=atoi(id);</span><br><span class="line">		job=getjobjid(jobs,pid);</span><br><span class="line">		<span class="keyword">if</span>(job==<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%d):NO such process\n&quot;</span>,pid);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kill(-(job-&gt;pid),SIGCONT);<span class="comment">//注意负号</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		job-&gt;state = BG;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid,job-&gt;cmdline);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		job-&gt;state = FG;</span><br><span class="line">		waitfg(( job-&gt;pid));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span><span class="comment">//直到结束</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pid==fgpid(jobs))</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>信号处理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="keyword">while</span>((pid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG|WUNTRACED))&gt;<span class="number">0</span>)<span class="comment">//原生的pid处理</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(status))deletejob(jobs,pid);<span class="comment">//正常终止</span></span><br><span class="line">		<span class="keyword">if</span>(WIFSIGNALED(status))<span class="comment">//是否为未被捕捉的信号终止</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>,pid2jid(pid),pid,WTERMSIG(status));</span><br><span class="line">			deletejob(jobs,pid);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(WIFSTOPPED(status))<span class="comment">//引起返回的子进程被停止</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>,pid2jid(pid),pid,WSTOPSIG(status));</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>=</span>getjobpid(jobs,pid);</span><br><span class="line">			<span class="keyword">if</span>(job!=<span class="literal">NULL</span>)job-&gt;state=ST;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下两个均为：收到-判断存在-杀进程</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">	<span class="keyword">if</span>(pid!=<span class="number">0</span>)	kill(-pid,SIGINT);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">	<span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>=</span>getjobjid(jobs,pid);</span><br><span class="line">		<span class="keyword">if</span>(job-&gt;state ==ST) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> kill(-pid,SIGTSTP);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>又分析了一遍系统函数，更加理解了子进程/信号处理的相关知识，但对进程组有点迷茫。</p>


<div class="article-footer fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body"><div class="post-title h2"><a href="/2021/04/29/2021-02-07-Pwn-emarm/">undefined</a></div><div class="post-title fs14"><a href="/2021/05/10/CE-learning/">上一篇：CE-learning</a></div></section></div>








      
<footer class="page-footer fs12"><hr><div><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="http://example.com/">@Zuni</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script')
      script.src = src
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper/swiper-bundle.min.css","js":"https://unpkg.com/swiper/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
